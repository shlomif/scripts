#!/usr/bin/env expect
#
# Feeds the commands in the given input file (or stdin) to the
# subsequent program; this allows one to have a vi buffer, and then
# launch a REPL via something like
#
#   :!feed % clisp -q -q
#
# The buffer commands will be input into the program, and then the REPL
# can be interacted with as necessary. (No, I do not use slime.) If the
# first argument is "-" input will instead be read from stdin; this may
# not be reliable on account of the need to restore access to the tty
# for interactive use (if it "does not work" please let me know):
#
#   (echo set x 42; echo set y 15.238095238095237) | feed - tclsh
#   ...
#
#   echo run -al | feed - gdb ls
#   ...
#
# There is (not very tested) support for clisp, gdb, perl -d, sbcl,
# tinyrepl, and various TCL shell programs. Other REPL will require
# adjustments to the code, in particular what if any prompt is looked
# for, and how to handle blank lines and comments, given that this code
# is not very intelligent about what is passed through; look for things
# to TWEAK.
#
# This code assumes a TCL version >= 8.5

set prog_name [lindex [split $argv0 "/"] end]
if {[llength $argv] < 2} {
    puts stderr "Usage: $prog_name file|- command \[command-args ..]"
    exit 64
}

# TWEAK borrowed from autoexpect output, see expect man page for details
# on how to slow things down if necessary
#set send_slow {1 .1}
#proc send {ignore arg} {
#    sleep .1
#    exp_send -s -- $arg
#}

# TWEAK a lowered timeout may be necessary depending on the input and
# how well prompts can be detected (in particular whether the REPL
# accepts only a single line of input (Perl) or allows for continuation
# lines (LISP, TCL).
#set timeout .5
set timeout 3

# for Tcl version of mktemp(1)
package require Tcl 8
package require fileutil

proc warn {msg} {
    global prog_name
    puts stderr "$prog_name: $msg"
}
proc die {args} {
    if {[llength $args] > 0} { warn $args }
    exit 1
}

# first argument is where the commands come from: stdin or from a file?
set argv [lassign $argv input_file];  # it's shift, Jim, but not as we know it

if {$input_file eq "-"} {
    # copy stdin into a tmp file and then hopefully restore access to tty
    set tmpfile [::fileutil::tempfile "$prog_name-"]
    trap {file delete $tmpfile; puts ""; exit 1} {SIGHUP SIGINT SIGPIPE SIGTERM}
    if {[catch {set tmpfh [open $tmpfile w]} err]} {
        file delete $tmpfile
        die $err
    }
    while {[gets stdin line] >= 0} {
        puts $tmpfh $line
    }
    if {[catch {close $tmpfh} err]} {
        file delete $tmpfile
        die $err
    }
    close stdin
    open /dev/tty r+
    if {[catch {set input_fh [open $tmpfile r]} err]} {
        file delete $tmpfile
        die $err
    }
} else {
    # regular file input
    if {[catch {set input_fh [open $input_file r]} err]} {
        die $err
    }
    set tmpfile ""
}

if {[catch {spawn -noecho {*}$argv} err]} {
    if {$tmpfile ne ""} { file delete $tmpfile }
    die $err
}

# TWEAK and here we try to figure out hopefully a 90% solution for feeding
# of varied inputs to varied REPL
set tocall [lindex $argv 0]
                                                               # LISP
if {$tocall eq "clisp" || $tocall eq "sbcl"} {
    proc dosomethingwith {line} {

        # both clisp and sbcl hang on ; comments so must skip
        # also skip blank lines as haven't seen those within code blocks...
        if {[regexp {^[:blank:]*(;|$)} $line]} { return }

        # "(foo" or "  (foo" guess it's a line that will be followed by
        # more such lines so don't waste time waiting on a prompt
        if {![regexp {^[:blank:]*\(} $line]} {
            expect -re {^(\*|[^>]*>) }
        }

        send -- "$line\r"
    }
                                                               # Perl
} elseif {($tocall eq "perl" && "-d" in $argv)
  || $tocall eq "tinyrepl"} {
    proc dosomethingwith {line} {

        if {[regexp {^[:blank:]*(#|$)} $line]} { return }

        # there be escape sequences that make these trick to bind to the
        # beginning of the line...
        expect -re {(  DB<|re\.pl\$ )}

        send -- "$line\r"
    }
                                                               # TCL
} elseif {$tocall eq "expect"
  || [string match "tclsh*" $tocall]
  || [string match "wish*" $tocall]} {
    proc dosomethingwith {line} {

        # skip any blank or comment-looking line, regardless
        if {[regexp {^[:blank:]*(;?#|$)} $line]} { return }

        # don't wait for prompt if line looks like continuation (via the
        # leading whitespace)
        if {![regexp {^[:blank:]*} $line]} {
            # default "% " prompt or I've instead set tcl_prompt1 to "foo> "
            expect -re {^(%|[^>]*>) }
        }

        send -- "$line\r"
    }
                                                               # GDB
} elseif {$tocall eq "gdb"} {
    proc dosomethingwith {line} {

        # assume hash and blank lines are comments around gdb commands
        # in the input and skip
        if {[regexp {^[:blank:]*(#|$)} $line]} { return }

        # TODO does this change? (or also (lldb) for llvm but that on
        # Apple is always failing from the cli due to integrity checks
        # or whatnot so ignore
        expect -ex "(gdb)"

        send -- "$line\r"
    }
                                                               # default
} else {
    # assume # as comments and send the rest through; probably adequate
    # for shell scripts and doubtless other things though does not wait
    # for any prompt
    proc dosomethingwith {line} {
        if {[regexp {^[:blank:]*#} $line]} { return }
        send -- "$line\r"
    }
}

while {[gets $input_fh line] >= 0} { dosomethingwith $line }

# control+z will background feed (and whatever being run) while for
# control+c that is passed through to the program being run.
set CONTROL_C \003
set CONTROL_Z \032
trap {puts ""; exit 1} {SIGHUP SIGPIPE SIGTERM}
#trap SIG_IGN SIGINT
trap {send $CONTROL_C} SIGINT

if {$tmpfile ne ""} { file delete $tmpfile }
if {[catch {close $input_fh} err]} { die $err }

# and hand REPL over to the bluberous fleshy mandibles of the user
interact {
    $CONTROL_C {send -raw $CONTROL_C}
    -reset $CONTROL_Z {exec kill -STOP [pid]}
}
