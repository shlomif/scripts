#!/usr/bin/env perl
#
# Means to prompt for human interaction.

use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use Term::ReadKey qw(ReadKey ReadMode);

open my $ttyfh, '+<', '/dev/tty' or die "getraw: could not open tty: $!\n";
# NOTE olden versions of perl may require IO::Handle loaded for this
$ttyfh->autoflush(1);

Getopt::Long::Configure("bundling");
GetOptions(
    'delay|d=f'     => \my $Flag_Delay,
    'help|h|?'      => \&emit_help,
    'newline|n'     => \my $Flag_Newline,
    'return|r'      => \my $Flag_Return,
    'sigstatus|S=i' => \my $Flag_Signal_Status,
    'spec|o=s'      => \my $Flag_Spec,
    'tostatus|T=i'  => \my $Flag_Timeout_Status,
    'timeout|t=s'   => \my $Flag_Timeout,
) or exit 65;

$Flag_Delay          = -1 if !defined $Flag_Delay;
$Flag_Signal_Status  = 3  if !defined $Flag_Signal_Status;
$Flag_Timeout_Status = 4  if !defined $Flag_Timeout_Status;

my $keys2exit = parse_spec( defined $Flag_Spec ? $Flag_Spec : 'Yy:0 Nn:2' );

print $ttyfh "@ARGV" if @ARGV;

my $timeout = defined $Flag_Timeout ? duration2seconds($Flag_Timeout) : -1;

for my $s (qw/HUP INT TERM USR1 USR2/) { $SIG{$s} = \&sig_bail }
ReadMode( 3, $ttyfh );

my $exit_status = -1;
eval {
    if ( $timeout > 0 ) {
        $SIG{ALRM} = sub { die "alarm\n" };
        alarm $timeout;
    }

    # eat up leading input within the timeout to avoid an infinite
    # wait in the (unlikely?) case there is infinite input being fed
    # in fast enough
    if ( $Flag_Delay > 0 ) {
        select( undef, undef, undef, $Flag_Delay );
        # eager beaver prevention: drain everything queued
        my $key;
        do {
            # NOTE PORTABILITY may die with fatal error (see docs for function)
            $key = ReadKey( -1, $ttyfh );
        } until !defined $key;
    }

    while (1) {
        my $key = ReadKey( 0, $ttyfh );
        my $code = $keys2exit->{$key};
        $code = $keys2exit->{any} if !defined $code;
        if ( defined $code ) {
            $exit_status = $code;
            last;
        }
    }
    alarm 0 if $timeout > 0;
};
if ($@) {
    if ( $@ eq "alarm\n" ) {
        $exit_status = $Flag_Timeout_Status;
    } else {
        die "getraw: unexpected failure: $@";
    }
}
exit $exit_status;

END {
    if ( defined $ttyfh ) {
        print $ttyfh "\r" if $Flag_Return;
        print $ttyfh "\n" if $Flag_Newline;
        ReadMode( 0, $ttyfh );
        close $ttyfh;
    }
}

######################################################################
#
# SUBROUTINES

sub duration2seconds {
    my ($duration) = @_;

    my %factor = (
        'w' => 604800,
        'd' => 86400,
        'h' => 3600,
        'm' => 60,
        's' => 1,
    );

    my $seconds;

    if ( $duration =~ m/^[0-9]+$/ ) {
        $seconds = $duration;
    } else {
        while ( $duration =~ m/([0-9]+)([smhdw])/g ) {
            $seconds += $1 * $factor{$2};
        }
        die "getraw: could not parse duration '$duration'" if !defined $seconds;
    }

    return $seconds;
}

sub emit_help {
    warn <<"END_USAGE";
Usage: getraw [options] [prompt message]

Means to prompt for human interaction.

  -d ff  Delay readkey by this many fractional seconds.
  -n     Emit newline to tty before exit.
  -r     Emit return to tty before exit.
  -o ss  Use custom key to exit code specification.
  -t dur Timeout getraw after this many seconds (or 1m2s shorthand).

END_USAGE
    exit 64;
}

sub parse_spec {
    my ($string) = @_;
    my %keys2exit;

    for ( split /(?<!\\)[ ]+/, $string ) {
        my ( $keys, $status ) = /(.+?):([0-9]+)?$/;
        die "getraw: could not parse specification '$_'" if !defined $keys;

        if ( $keys =~ s/(?<!\\)\*// ) {
            # default action via the so-called "any" key
            $keys2exit{any} = $status;
        }

        # unescape backwhacked things (\r, etc.)
        $keys =~ s/(\\.)/qq("$1")/eeg;

        for my $k ( split //, $keys ) {
            die "getraw: specification for key '$k' already exists\n"
              if exists $keys2exit{$k};
            $keys2exit{$k} = $status;
        }
    }

    die "getraw: unable to parse specification '$string'"
      if keys %keys2exit == 0;

    return \%keys2exit;
}

sub sig_bail { exit $Flag_Signal_Status }    # and then to the END
