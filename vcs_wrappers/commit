#!/usr/bin/env perl
#
# Wrapper to commit changes back to version control programs. See
# __DATA__ for example configuration file for this script. See also the
# 'di' and 'ketchup' scripts.
#
# TODO add status/add checking support, to avoid "commit" grrr! "add"
# "commit" annoyance. TODO means to order what version control software
# detected first (in the event have git mixed in with something else).

use strict;
use warnings;

use Cwd qw(getcwd realpath);
use File::Basename;
use File::HomeDir qw(my_home);
use File::Spec ();

my %defaults = ( class => 'commit' );

my $prefs_file = $ENV{COMMITCONF} || '~/.commit/prefs';
$prefs_file = tilde_expand($prefs_file);
my $prefs = load_prefs($prefs_file);

use Getopt::Std;
my %opts;
getopts 'h?F:m:r:n', \%opts;

$defaults{revision} = $opts{r} if exists $opts{r};
if ( exists $opts{m} ) {
    $defaults{msg} = $opts{m};
} elsif ( exists $opts{F} ) {
    $defaults{msgfile} = $opts{F};
}

# default to "current" directory if no args (to emulate 'cvs ci'
# without args)
@ARGV = qw(.) unless @ARGV;

# where to store filenames for handling
my ( %tocommit, @unknown );

for my $file (@ARGV) {
    my ( $filename, $filepath, undef ) = fileparse($file);

    # Might be problematic for mixed repositories, but I don't do that,
    # so there.
    if ( defined findup('.git') ) {
        push @{ $tocommit{git} }, $file unless $file eq '.git';

    } elsif ( defined findup('.p4config') ) {
        push @{ $tocommit{perforce} }, $file unless $file eq '.p4config';

    } elsif ( -f File::Spec->catfile( $filepath, qw{CVS Root} ) ) {
        push @{ $tocommit{cvs} }, $file unless $file eq 'CVS';

        # Current versions use a sole .svn file. Still mad at SVN for it
        # eating my data and totally wedging on me, though.
    } elsif ( defined findup('.svn') ) {
        push @{ $tocommit{svn} }, $file unless $file eq '.svn';

    } else {
        push @unknown, $file;
    }
}

for my $commit_type ( sort keys %tocommit ) {

    my %tmp = ( %{ $prefs->{commit}->{$commit_type} }, %defaults );

    # delete "whateveropt" where no "whatever" exists
    for my $option ( keys %tmp ) {
        delete $tmp{$option} if $option =~ /(\w+)opt$/ and not exists $tmp{$1};
    }

    my @command = map {
        s/\Q%{\E(\w+)\Q}\E/$tmp{$1}||q{}/ge;
        defined and $_ ne q{} ? $_ : ()
    } split /\s+/, $tmp{exec};

    # for "preview" mode, though this will not show required shell quotes
    # around things like a -m commit message
    unshift @command, 'echo' if exists $opts{n};

    unless ( system( @command, @{ $tocommit{$commit_type} } ) == 0 ) {
        my $exit_status = $? >> 8;
        remark(
            'warning',
            'bad exit status',
            { value => $exit_status, type => $commit_type }
        );
    }
}

if (@unknown) {
    local $" = ',';
    remark( 'warning', 'no method to handle', { files => "@unknown" } );
}

sub findup {
    my $filename = shift;
    my $cur_dir  = getcwd();

    my $homedir = realpath( my_home() );

    my @dirs = File::Spec->splitdir($cur_dir);
    do {
        my $work_dir = File::Spec->catdir(@dirs);

        # Abort if hit homedir, as can find global .p4config or whatnot in
        # this or higher directories.
        my $real_work_dir = realpath($work_dir);
        if ( $real_work_dir eq $homedir ) {
            return;
        }

        if ( -e File::Spec->catfile( $work_dir, $filename ) ) {
            return $work_dir;
        }
        pop @dirs;
    } until ( !@dirs );

    return;
}

sub remark {
    my $priority   = shift;
    my $message    = shift;
    my $attributes = shift;

    chomp $message;

    my $attr_str;
    if ($attributes) {
        $attr_str = join ', ', map { $attributes->{$_} ||= q{}; "$_=$attributes->{$_}" }
          sort keys %$attributes;
    }

    warn "$priority: $message", ( $attr_str ? ": $attr_str" : q{} ), "\n";
    return 1;
}

# expands ~username syntax to full home directory path
sub tilde_expand {
    for (@_) {
        s{^ ~      # leading tilde
      ([^/]*)  # preserve following data
     }{
      $1 ? (getpwnam $1)[7] : (getpwuid $<)[7] || $ENV{HOME}
        || remark('error',
             'could not lookup user or HOME not set',
             { file => $_ })
        && exit 74;
     }ex;
    }
    return wantarray ? @_ : "@_";
}

sub load_prefs {
    my $file = shift;

    open my $fh, "< $file"
      or remark( 'error', 'could not load preferences', { file => $file } )
      and exit 78;

    my %prefs;
    my %tmp = %defaults;

    while (<$fh>) {
        s/^\s+//;
        next if /^#/;
        chomp;

        if (/^$/) {
            pref_finish( \%tmp, \%prefs ) if exists $tmp{name};
            %tmp = %defaults;
            next;
        }

        s/\s+$//;

        my ( $k, $v ) = split /\s+/, $_, 2;
        unless ( defined $k and $k =~ /^[\w.-]+$/ and defined $v ) {
            remark( 'warning', 'skipping invalid data', { file => 'prefs', line => $. } );
            next;
        }
        $tmp{$k} = $v;
    }
    pref_finish( \%tmp, \%prefs ) if exists $tmp{name};

    return \%prefs;
}

sub pref_finish {
    my $tmp   = shift;
    my $prefs = shift;

    $prefs->{ $tmp->{class} }->{ $tmp->{name} } = {%$tmp};
}

__DATA__
# Example ~/.commit/prefs data
name cvs
exec cvs ci %{revisionopt} %{revision} %{msgfileopt} %{msgfile} %{msgopt} %{msg} %{files}
msgfileopt -F
msgopt -m
revisionopt -r

name svn
exec svn ci %{revisionopt} %{revision} %{msgfileopt} %{msgfile} %{msgopt} %{msg} %{files}
msgfileopt -F
msgopt -m
revisionopt -r

# TODO often use 'git commit -a' how support that mode?
name git
exec git commit %{msgopt} %{msg} %{files}
msgopt -m

name perforce
exec p4 submit %{revisionopt} %{revision} %{msgopt} %{msg}
msgopt -d
revisionopt -c
