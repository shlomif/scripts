#!/usr/bin/env perl
#
# Converts epoch times to strings perhaps more readable by humans.

use 5.14.0;
use warnings;
use File::Basename qw(basename);
use Getopt::Long qw(GetOptions);
use POSIX qw(strftime);

my $prog_name = basename($0);
my $timefunc = $prog_name eq 'epoch2gmdate' ? \&time_gmt : \&time_loco;

GetOptions(
    'format|f=s'           => \my $Flag_Format,
    'gmtime|g'             => sub { $timefunc = \&time_gmt },
    'help|h|?'             => \&emit_help,
    'localtime|locotime|l' => sub { $timefunc = \&time_loco },
) or exit 65;

emit_help() unless @ARGV;

$Flag_Format //= '%Y-%m-%d %H:%M:%S %Z';
$Flag_Format =~ s/(\\.)/qq!"$1"!/eeg;    # '\n' to "\n", essentially

@ARGV = readline *STDIN if $ARGV[0] eq '-';

for my $entry (@ARGV) {
    # negative epoch dubious? but why not
    for my $epoch ( $entry =~ m/(-?[0-9]+)/g ) {
        # NOTE systemtap apparently uses a microseconds-based epoch
        # (1475682078014325 -> 1475682078 014325) without being sensible
        # enough to put a dot or something between the elements. Sigh.
        # KLUGE smart guess which is which
        if ( length $epoch > 11 ) {
            warn_once("notice: guess microseconds for $epoch\n");
            $epoch /= 1e6;
        }
        say strftime( $Flag_Format, $timefunc->($epoch) );
    }
}

sub emit_help {
    warn <<"END_USAGE";
Usage: $prog_name [options] epoch-numbers|-

Converts unix epoch to human readable dates.

  -f fmt  strftime(3) format for output date.

  -g      Use gmtime() call.
  -l      Use localtime() call (default).

END_USAGE
    exit 64;
}

# loco (crazy) on account of the horrible daylight savings time thing
sub time_loco { localtime $_[0] }
sub time_gmt  { gmtime $_[0] }

sub warn_once {
    state $has_warned;
    return if $has_warned;
    warn $_[0];
    $has_warned = 1;
}
