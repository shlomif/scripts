#!/usr/bin/env perl
#
# rlytest - test mail host for third-party relay
# (see POD documentation at end)
#
# Chip Rosenthal
# Unicom Systems Development
# <chip@unicom.com>
#
# Jeremy Mates localized rlytest 1.22 into my scripts repository to
# apply patch to allow rlytest to work against arbitrary ports instead
# of just 25 on 2003-02-23. And then the rest is history.

use strict;
use warnings;

use Getopt::Std qw/getopts/;
use POSIX qw/strftime/;
use Sys::Hostname qw/hostname/;
use Term::ANSIColor;

my $socket_class;
eval { require IO::Socket::INET6 };
if ($@) {
  require IO::Socket;
  $socket_class = 'IO::Socket::INET';
} else {
  require IO::Socket::INET6;
  $socket_class = 'IO::Socket::INET6';
}

use vars qw($Usage $Dflt_hostname $Dflt_domain $Root_check %Opts
  $Local_host $Target_host $Port $Timeout $Hostname $Username $Comment
  $Actual_sender $MailFrom_addr $RcptTo_addr $Hdr_to $Hdr_from $Mssg_body);

$Usage =
  "usage: $0 [-f sender_addr] [-u recip_addr] -s [header_sender] -r [header_recip] [-c comment] [-t timeout] [-p port] target_host";

use vars qw($EX_RELAY_ACCEPTED $EX_RELAY_REJECTED $EX_PROGRAM_ERROR);
$EX_RELAY_REJECTED = 0;
$EX_RELAY_ACCEPTED = 2;
$EX_PROGRAM_ERROR  = 1;

#
# Host name configuration - Leave these commented out unless the
# calculate_fqdn() routine is unable to calculate your FQDN (fully
# qualified domain name) correctly.  You'll know if it fails, because
# the script will bomb out bitching about the FQDN.  If this happens,
# try setting $Dflt_domain to your domain.  Or, if you like, you
# may hardwire $Dflt_hostname to a particular FQDN.
#
### $Dflt_domain = "example.com";
### $Dflt_hostname = "dopey.example.com";

#
# Unbuffered output.
#
autoflush STDOUT 1;

#
# Crack command line.
#
getopts( 'Ac:Ef:I:t:u:p:mgs:Sr', \%Opts )
  or die "$Usage";
die "$Usage\n"
  unless ( @ARGV == 1 );
$Target_host = shift;

#
# Initialize parameters.
#
$Opts{E} = 1 if exists $Opts{S};    # need EHLO to get SIZE
$Timeout = $Opts{t} || 300;
$Hostname = calculate_fqdn()
  or die "$0: cannot determine FQDN\n";
$Port = $Opts{p} || 25;             # default to SMTP port
$Username      = $ENV{LOGNAME} || $ENV{USER} || die "$0: LOGNAME undefined\n";
$Actual_sender = $Username . '@' . $Hostname;
$RcptTo_addr   = $Opts{u} || $Actual_sender;
$Comment       = defined $Opts{c} ? "$Opts{c}\n" : '';
my $helo = $Opts{E} ? 'EHLO' : 'HELO';

if ( defined $Opts{f} ) {
  $MailFrom_addr = $Opts{f};
} elsif ( $Target_host =~ /^\d+\.\d+\.\d+\.\d+$/ or $Target_host =~ m/:/ ) {
  $MailFrom_addr = "nobody\@[${Target_host}]";
} else {
  $MailFrom_addr = "nobody\@${Target_host}";
}

if ( defined $Opts{s} ) {
  $Hdr_to = $Opts{s};
} else {
  $Hdr_to = $RcptTo_addr;
}

if ( defined $Opts{r} ) {
  $Hdr_from = $Opts{r};
} else {
  $Hdr_from = $MailFrom_addr;
}

#
# Construct the test message.
#
$Mssg_body =
    "To: $Hdr_to\n"
  . "From: $Hdr_from\n"
  . "Subject: test for susceptibility to third-party mail relay\n"
  . "Date: "
  . arpa_date( time() ) . "\n"
  . "Message-Id: <rlytest-"
  . time() . "-"
  . $$
  . "\@$Hostname>\n"
  . "Sender: $Actual_sender\n" . qq[
This message is a test probe, to ensure that your mail server is secured
against third-party mail relay. This is NOT an attempt to hack or crack
your system, but just to ensure the system are secured against this
common vulnerability. This test usually is performed by a system
administrator who is trying to determine the source of a spam email.

A well-configured mail server should NOT relay third-party email.
Otherwise, the server is subject to attack and hijack by Internet
vandals and spammers. For information on how to secure a mail server
against third-party relay, visit <URL: http://mail-abuse.org/tsi/>.

This probe was generated by the "rlytest" utility.

    Target host = $Target_host
    Test performed by <$Actual_sender>

If you have any concern about this test, please contact the person listed
in the "test performed by" line above.

${Comment}
];

#
# Connect and execute SMTP dialog.
#
print color 'bold red' if $Opts{m};
print "Connecting to $Target_host ...\n";
print color 'reset' if $Opts{m};
system qw(getraw -o *:+) if $Opts{g};
my $sock = $socket_class->new(
  ( defined $Local_host ? ( LocalAddr => $Local_host ) : () ),
  Proto    => "tcp",
  PeerAddr => $Target_host,
  PeerPort => $Port,
  Timeout  => $Timeout,
) or die "$0: socket failed: cannot connect to $Target_host: $@\n";

$SIG{ALRM} = sub { die "$0: timeout waiting for socket I/O\n"; };
$sock->autoflush(1);
read_response($sock);
system qw(getraw -o *:+) if $Opts{g};
write_command( $sock, "$helo $Hostname\n" );
system qw(getraw -o *:+) if $Opts{g};
write_command( $sock, "MAIL FROM:<$MailFrom_addr>\n" );
system qw(getraw -o *:+) if $Opts{g};
write_command( $sock, "RCPT TO:<$RcptTo_addr>\n" );

goto ALL_DONE if $Opts{A};

system qw(getraw -o *:+) if $Opts{g};
write_command( $sock, "DATA\n" );
system qw(getraw -o *:+) if $Opts{g};
write_command( $sock, $Mssg_body, "(message body)\n", 1 );

if ( defined $Opts{S} and $Opts{S} =~ m/^\d+$/ ) {
  my $str =
    "QWxsIHdvcmsgYW5kIG5vIHBsYXkgbWFrZXMgSmFjayBhIER1bGwgQm95Cg==\r\n";
  my $str_len    = length $str;
  my $sent_bytes = length $Mssg_body;
  while ( $sent_bytes < $Opts{S} ) {
    alarm($Timeout);
    $sock->print($str)
      or die "$0: socket write failed [$!]\n";
    alarm(0);
    $sent_bytes += $str_len;
  }
}

write_command( $sock, ".\n", "(message EOF)\n" );
ALL_DONE:
my $code = write_command( $sock, "QUIT\n" );

#
# Dialog successful
#
warn "$0: relay accepted - final response code $code\n";
exit($EX_RELAY_ACCEPTED);

#
# usage: write_command($sock, $data_to_send[, $mssg_to_display])
#
sub write_command {
  my $sock      = shift;
  my $data      = shift;
  my $mssg      = shift || $data;
  my $skip_read = shift || 0;
  print color 'bold red' if $Opts{m};
  print ">>> $mssg";
  print color 'reset' if $Opts{m};
  $data =~ s/\n/\r\n/g;
  alarm($Timeout);
  $sock->print($data)
    or die "$0: socket write failed [$!]\n";
  alarm(0);
  return read_response($sock) if !$skip_read;
}

#
# usage: $response_code = read_response($sock);
#
sub read_response {
  my $sock = shift;
  my ( $code, $cont, $mssg );

  do {
    alarm($Timeout);
    chop( $_ = $sock->getline() );
    alarm(0);
    ( $code, $cont, $mssg ) = /(\d\d\d)(.)(.*)/;

    if ( $Opts{S} and $mssg =~ m/SIZE\s(\d+)/ ) {
      $Opts{S} = $1 * 2;
    }

    print color 'bold blue' if $Opts{m};
    print "<<< ", $_, "\n";
    print color 'reset' if $Opts{m};
  } while ( $cont eq "-" );
  return $code
    if ( $code >= 200 && $code < 400 );

  alarm($Timeout);
  $sock->print("QUIT\r\n");
  alarm(0);
  warn "$0: relay rejected - final response code $code\n";
  exit($EX_RELAY_REJECTED);
}

#
# usage: $hostname = calculate_fqdn();
#
sub calculate_fqdn {
  return $Dflt_hostname
    if ($Dflt_hostname);
  my $host = hostname();
  warn "notice: using hostname $host\n";
  return $host;
}

#
# usage: $date_header = arpa_date($secs_since_epoch)
#
sub arpa_date {
  my $epoch = shift || 0;
  strftime "%a, %d %b %Y %H:%M:%S GMT", gmtime $epoch;
}

__END__

=head1 NAME

rlytest - test mail host for third-party relay

=head1 SYNOPSIS

B<rlytest>
[B<-f> sender_addr]
[B<-u> recip_addr]
[B<-c> I<comment>]
[B<-t> I<timeout>]
[B<-p> I<port>]
I<target_host>

Among other options.

=head1 DESCRIPTION

The B<rlytest> utility performs a test on I<target_host> to determine
whether it will relay third-party email.  It will try to relay an
email message to yourself through that host.  A host that allows
third-party relay is subject to attack by Internet vandals, and
frequently is hijacked by spammers to relay massive amounts of junk
email.  A host that allows third-party relay should be B<immediately>
secured, disconnected, or shunned as a menace to the Internet.

The following options are available (and probably more, see source):

=over 4

=item B<-A>

Abort the connection before sending C<DATA>.

=item B<-c> I<comment>

Embed I<comment> in the body of the test message.  This may
be useful, for instance, if you are doing some automatic testing
and want to insert cookies into the messages.

=item B<-E>

Use C<EHLO> instead of C<HELO>.

=item B<-f> I<sender_addr>

Specifies the (C<MAIL FROM>) email address to use on the probe.
By default, B<rlytest> tries to calculate an email address in the
target domain.  This is to ensure that the host is not using simple
(and easily defeated) envelope checks for anti-relay protection.

=item B<-I> I<localaddr>

Specify local address for the socket call. NOTE this may need to agree
with DNS or other attributes of the SMTP conversation, as some sites
check that a PTR exists, or other checks. Or not, if you expect the test
to fail, and are making sure it does.

=item B<-p> I<port>

Connects to the SMTP server on the specified port instead of the
default port 25.

=item B<-S>

Sends more data than the SIZE limit of the server allows. Turns on B<-
E> to send C<EHLO>. Disabled if remote server does not advertise a
C<SIZE> limit.

=item B<-t> I<timeout>

Sets the timeout value (default is 60 seconds) for certain
operations.

=item B<-u> I<recip_addr>

Specifies the (C<RCPT TO>) email address to use on the probe.  By
default, B<rlytest> tries to calculate your email address and use
that.  A host that is susceptible to relay will deliver a probe
message to this address.

=back

If the remote host refused to relay the message, the program
will terminate with a zero exit status display a message to
I<stderr> similar to:

  rlytest: relay rejected - status code 571

If the message was accepted, the program will terminate with an
exit status of 2 and display a message to I<stderr> similar to:

  rlytest: relay accepted - status code 221

Any other (non-zero) exit status indicates a program error, such as a
bad hostname or host not responding.

=head1 EXAMPLE

Here is an example, showing a host that refuses third-party relay:

  $ ./rlytest mail.example.dom
  Connecting to mail.example.dom ...
  <<< 220 mail.example.dom ready
  >>> HELO garcon.unicom.com
  <<< 250 Hello garcon.unicom.com, pleased to meet you
  >>> MAIL FROM:<nobody@mail.example.dom>
  <<< 250 <chip@garcon.unicom.com>... Sender ok
  >>> RCPT TO:<chip@garcon.unicom.com>
  <<< 550 <chip@garcon.unicom.com>... Relaying Denied
  rlytest: relay rejected - status code 550

=head1 BUGS

There is no reliable and portable method to determine the local fully
qualified domain name. If the utility bombs out complaining about FQDN
problems, read the "host name configuration" information near the top of
the script.

=head1 SEE ALSO

mail(1), sendmail(8)

=head1 AUTHOR

  Chip Rosenthal
  Unicom Systems Development
  <chip@unicom.com>

  See http://www.unicom.com/sw/#rlytest for latest version.

Jeremy Mates localized rlytest 1.22 into my scripts repository to apply
patch to allow rlytest to work against arbitrary ports instead of just
25 on 2003-02-23. And then the rest is history.
