#!/usr/bin/env perl
#
# Reports if IPv4 address or IPv4 address(es) of a host exist in a RBL.
# Input via command arguments or failing that standard input.
#
# TODO no error from getaddrinfo() if off the Internet, so instead use
# Net::DNS for those lookups?

use 5.14.0;
use warnings;

use Socket qw(:addrinfo unpack_sockaddr_in inet_ntop AF_INET);

# Culled from: http://cbl.abuseat.org/ http://www.spamhaus.org/zen/
my @RBLS = qw(
  cbl.abuseat.org.
  zen.spamhaus.org.
);
my %RBL_TYPES = (
    'cbl.abuseat.org. 127.0.0.2'   => 'blacklisted',
    'zen.spamhaus.org. 127.0.0.2'  => 'SBL (spammers)',
    'zen.spamhaus.org. 127.0.0.3'  => 'CSS (snowshoe)',
    'zen.spamhaus.org. 127.0.0.4'  => 'XBL (exploit)',
    'zen.spamhaus.org. 127.0.0.5'  => 'XBL (exploit)',
    'zen.spamhaus.org. 127.0.0.6'  => 'XBL (exploit)',
    'zen.spamhaus.org. 127.0.0.7'  => 'XBL (exploit)',
    'zen.spamhaus.org. 127.0.0.10' => 'PBL (non-MTA ip)',
    'zen.spamhaus.org. 127.0.0.11' => 'PBL (non-MTA ip)',
);

state %rblseen;

chomp( @ARGV = readline *STDIN )
  if !@ARGV
  or ( @ARGV == 1 and $ARGV[0] eq '-' );

for my $entry (@ARGV) {
    for my $ret ( lookup($entry) ) {
        my @octets = segments($ret);
        next unless @octets;
        for my $rbl (@RBLS) {
            for my $rbl_ret ( lookup( rblhost( $rbl, @octets ), 1 ) ) {
                my $result = rblresult($rbl_ret);
                my $key    = "$rbl $result";
                next if $rblseen{$key}++;
                $result = $RBL_TYPES{$key} if exists $RBL_TYPES{$key};
                say "$entry $rbl $result";
            }
        }
    }
}

exit 0;

sub lookup {
    my ( $lookup, $Flag_Quiet ) = @_;
    # Only IPv4, as have seen precious little spam via IPv6 as of July
    # 2014; just some random *.ru dialups, really.
    my ( $err, @results ) = getaddrinfo( $lookup, undef, { family => AF_INET } );
    if ( defined $err and length $err and !$Flag_Quiet ) {
        warn "warning: could not lookup '$lookup': $err\n";
    }
    return @results;
}

sub rblhost {
    my ( $rbl, @octets ) = @_;
    return join( '.', reverse @octets ) . '.' . $rbl;
}

sub rblresult {
    my $sock = shift;
    my ( undef, $paddr ) = unpack_sockaddr_in( $sock->{addr} );
    return inet_ntop( AF_INET, $paddr );
}

sub segments {
    my $sock = shift;
    state %seen;
    my ( undef, $paddr ) = unpack_sockaddr_in( $sock->{addr} );
    return if $seen{$paddr}++;
    return split /[.]/, inet_ntop( AF_INET, $paddr );
}
